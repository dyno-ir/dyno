

TEST_CASE :string("instcombine-constants"), :block, :block, :block {
  MODULE_DEF :module("mod"), :block {
    OUTPUT_REGISTER_DEF %out_a:register(128)
    COMB_PROCESS_DEF :process, :block {
      ADD %0:wire(64), #64'd41, #64'h1, #64'h0
      ZEXT %1:wire(65), %0
      MUL %2:wire(65), %1, #65'h100000000
      SEXT %3:wire(128), %2
      SLL %4:wire(128), %3, #128'd90
      XOR %5:wire(128), %4, %4, %4, #32'd1
      SRA %6:wire(128), %5, #128'd127
      SDIV %7:wire(128), #128'd128, %6
      SUB %8:wire(128), #128'd1, %7
      ICMP_EQ %9:wire(1), %8, #128'd129
      CONCAT %10:wire(32), #31'h0, %9
      STORE %10, %out_a
    }
  }
}{
  MODULE_DEF :module("mod"), :block {
    OUTPUT_REGISTER_DEF %out_a:register(128)
    COMB_PROCESS_DEF :process, :block {
      STORE #32'd1, %out_a
    }
  }
}{
  meta.INST_COMBINE_PASS
}

TEST_CASE :string("fuzzy-cse-basic"), :block, :block, :block {
  MODULE_DEF :module("mod"), :block {
    INPUT_REGISTER_DEF %in_a:register(32)
    INPUT_REGISTER_DEF %in_b:register(32)
    INPUT_REGISTER_DEF %in_c:register(32)
    OUTPUT_REGISTER_DEF %out_a:register(32)
    OUTPUT_REGISTER_DEF %out_b:register(32)

    COMB_PROCESS_DEF :process, :block {
      LOAD %a_v:wire(32), %in_a
      LOAD %b_v:wire(32), %in_b
      LOAD %c_v:wire(32), %in_c

      ADD %abc:wire(32), %a_v, %b_v, %c_v
      ADD %ac:wire(32), %a_v, %c_v

      STORE %abc, %out_a
      STORE %ac, %out_a
    }
  }
}{
  MODULE_DEF :module("mod"), :block {
    INPUT_REGISTER_DEF %in_a:register(32)
    INPUT_REGISTER_DEF %in_b:register(32)
    INPUT_REGISTER_DEF %in_c:register(32)
    OUTPUT_REGISTER_DEF %out_a:register(32)
    OUTPUT_REGISTER_DEF %out_b:register(32)

    COMB_PROCESS_DEF :process, :block {
      LOAD %a_v:wire(32), %in_a
      LOAD %c_v:wire(32), %in_c
      ADD %ac:wire(32), %a_v, %c_v

      LOAD %b_v:wire(32), %in_b
      ADD %abc:wire(32), %b_v, %ac

      STORE %abc, %out_a
      STORE %ac, %out_a
    }
  }
}{
  meta.FUZZY_CSE_PASS
  meta.ORDER_INSTRS_PASS
  meta.INST_COMBINE_PASS
}
