

macro const_negate $n -> $rv [{
  FatDynObjRef<> negated = cbuild.val((*$n.begin())->as<ConstantRef>()).neg().get();
  $rv = negated;
}]
macro const_add $lhs, $rhs -> $rv [{
  FatDynObjRef<> sum = cbuild.val((*$lhs.begin())->as<ConstantRef>()).add((*$rhs.begin())->as<ConstantRef>()).get();
  $rv = sum;
}]
macro constant_like $val, $other -> $rv [{
  FatDynObjRef<> constant = cbuild.val($val).resize(*(*$other.begin())->as<WireRef>().getNumBits(), false).get();
  $rv = constant;
}]
macro constant_like_anyorder_obj $val, $other -> $rv [{
  FatDynObjRef<> constant = cbuild.val($val).resize(*(*$other.begin()).as<WireRef>().getNumBits(), false).get();
  $rv = constant;
}]
macro wire_like $other -> $rv [{
  FatDynObjRef<> w = ctx.getWires().create((*$other.begin())->as<HWValue>().getNumBits()); $rv = w;
}]
macro wire_like2 $other -> $rv [{
  FatDynObjRef<> w2 = ctx.getWires().create((*$other.begin())->as<HWValue>().getNumBits()); $rv = w2;
}]
macro const_like_reg_len $op, $reg [{
  auto asConstant = (*$op.begin())->dyn_as<ConstantRef>();
  if (!asConstant) goto $fail;
  if (!asConstant.valueEquals(*(*$reg.begin())->as<RegisterRef>().getNumBits()))
    goto $fail;
}]
macro const_like_value_len $op, $wire [{
  auto asConstant = (*$op.begin())->dyn_as<ConstantRef>();
  if (!asConstant) goto $fail;
  if (!asConstant.valueEquals(*(*$wire.begin())->as<HWValue>().getNumBits()))
    goto $fail;
}]
macro const_len_of $obj -> $rv [{
  FatDynObjRef<> c = ConstantRef::fromU32(*(*$obj.begin())->as<HWValue>().getNumBits());
  $rv = c;
}]

macro const_len_of_minus1 $obj -> $rv [{
  FatDynObjRef<> c = ConstantRef::fromU32(*(*$obj.begin())->as<HWValue>().getNumBits() - 1);
  $rv = c;
}]

match {
  HW_MUX $out, #1'b1, $a, $b
}
replace $out -> $a

match {
  HW_MUX $out, #1'b0, $a, $b
}
replace $out -> $b

match {
  HW_REPEAT $out, $in
}
with [{
  auto lenOut = *(*$out.begin())->as<WireRef>().getNumBits();
  auto lenIn = *(*$in.begin())->as<HWValue>().getNumBits();
  if (lenOut != lenIn)
    goto $fail;
}]
replace $out -> $in


match {
  OP_XOR $out, $in, #'1
}
replace {
  OP_NOT $out, $in
}


// # ADD/SUB rules
// sub to add negated
match {
  OP_SUB $subRes, $lhs, $rhs
  OP_ADD $res, anyorder($subRes:HW_WIRE, $others...)
}
replace {
  OP_NOT $temp2:wire_like($subRes), $rhs
  OP_ADD $res, $others..., $lhs, $temp2, constant_like(#1'b1, $res)
}

// sub to add negated
match {
  OP_ADD $temp, $others...
  OP_SUB $res, $temp:HW_WIRE, $rhs
}
replace {
  OP_NOT $temp2:wire_like($temp), $rhs
  OP_ADD $res, $others..., $temp2, constant_like(#1'b1, $res)
}

// sub constant -> add constant
match {
  OP_SUB $out, $lhs, $rhs:CORE_CONSTANT
}
replace {
  OP_ADD $out, $lhs, const_negate($rhs)
}

// todo: more than two operands in first add
match {
  OP_ADD $temp, $negatedA, $negatedB
  OP_NOT $temp2, $temp:HW_WIRE
  OP_ADD $out, anyorder($temp2:HW_WIRE, $others...)
}
replace {
  OP_NOT $a:wire_like($negatedA), $negatedA
  OP_NOT $b:wire_like2($negatedB), $negatedB
  OP_ADD $out, $a, $b, $others..., constant_like(#1'b1, $negatedA)
}

// Sink add thru MUX
// todo: reverse matching for certain regions to allow matching MUX the other way around
match {
  OP_ADD $sum0, anyorder($x, $gated)
  HW_MUX $mux_val, $disable, $x:HW_WIRE, $sum0:HW_WIRE
  OP_ADD $out, anyorder($mux_val:HW_WIRE, $others...)
}
replace {
  HW_MUX $gated_mux:wire_like($x), $disable, constant_like(#1'b0, $sum0), $gated
  OP_ADD $out, $x, $gated_mux, $others...
}



// patterns like this would be dope
// match {
//   OP_AND $first_sum, $first_args...
//   OP_ZEXT $first_sum_ext, $first_sum:HW_WIRE
//   OP_AND $sum, anyorder($first_sum_ext:HW_WIRE, $second_args...)
// }
// replace {
//   (OP_ZEXT $ext_first_args:wire_like($first_args), $first_args)...
//   OP_AND $sum, $ext_first_args..., $second_args...
// }



// # LOAD/STORE opt
// load with superfluous indexing
match {
  HW_LOAD $out, $reg, #'0
}
replace {
  HW_LOAD $out, $reg
}

// store with superfluous indexing
match {
  $opc{HW_STORE, HW_STORE_DEFER} $val, $reg, #'0
}
replace {
  $opc defs=0 $val, $reg
}

match {
  HW_STORE_DEFER $val, $reg, $trig, #'0
}
replace {
  HW_STORE_DEFER defs=0 $val, $reg, $trig
}



// CONCAT OPT
// concat with zero length constant
match {
  HW_CONCAT $out, $pre..., #0', $post...
}
replace {
  HW_CONCAT $out, $pre..., $post...
}

match {
  HW_CONCAT $out, $x
}
replace $out -> $x



// Splice Opt
match {
  HW_SPLICE $out, $in, #32'b0
}
replace {
  OP_TRUNC $out, $in
}

match {
  HW_SPLICE $out, $in
}
replace {
  OP_TRUNC $out, $in
}

match {
  HW_SPLICE $temp, $in, $addrA, $termsA...
  HW_SPLICE $out, $temp:HW_WIRE, $addrB, $termsB...
}
with [{
  if (!(*$temp.begin())->as<WireRef>().hasSingleUse())
    goto $fail;
}]
replace {
  HW_SPLICE $out, $in, const_add($addrA, $addrB), $termsA..., $termsB...
}

// we need check duplicates of these. dyno dsl pattern matching should fix.
macro chk_const_diff_lens $self, $lhs, $rhs [{
  auto lhsBits = *(*$lhs.begin())->as<HWValue>().getNumBits();
  auto rhsBits = *(*$rhs.begin())->as<HWValue>().getNumBits();
  FatDynObjRef<> diff = ConstantRef::fromU32(lhsBits - rhsBits);
  if ((*$self.begin())->as<FatDynObjRef<>>() != diff)
    goto $fail;
}]
macro chk_const_len_of_minus1 $self, $obj [{
  FatDynObjRef<> c = ConstantRef::fromU32(*(*$obj.begin())->as<HWValue>().getNumBits() - 1);
  if ((*$self.begin())->as<FatDynObjRef<>>() != c)
    goto $fail;
}]



// trunc(ext()) patterns
match {
  $opc{OP_ZEXT, OP_SEXT, OP_ANYEXT} $ext, $x
  OP_TRUNC $out, $ext:HW_WIRE
}
with [{
  auto inBits = (*$x.begin())->as<HWValue>().getNumBits();
  auto outBits = (*$out.begin())->as<WireRef>().getNumBits();
  if (!(*outBits < *inBits))
    goto $fail;
}]
replace {
  OP_TRUNC $out, $x
}

match {
  $opc{OP_ZEXT, OP_SEXT, OP_ANYEXT} $ext, $x
  OP_TRUNC $out, $ext:HW_WIRE
}
with [{
  auto inBits = (*$x.begin())->as<HWValue>().getNumBits();
  auto outBits = (*$out.begin())->as<WireRef>().getNumBits();
  if (!(*outBits == *inBits))
    goto $fail;
}]
replace $out -> $x

match {
  $opc{OP_ZEXT, OP_SEXT, OP_ANYEXT} $ext, $x
  OP_TRUNC $out, $ext:HW_WIRE
}
with [{
  auto inBits = (*$x.begin())->as<HWValue>().getNumBits();
  auto outBits = (*$out.begin())->as<WireRef>().getNumBits();
  if (!(*outBits > *inBits))
    goto $fail;
}]
replace {
  $opc $out, $x
}



// trunc(load())
match {
  HW_LOAD $val, $reg
  OP_TRUNC $x, $val:HW_WIRE
}
with [{
  if ((*$val.begin())->as<WireRef>().getNumUses() != 1)
    goto $fail;
}]
replace {
  HW_LOAD $x, $reg
}

match {
  HW_LOAD $val, $reg, $offs
  OP_TRUNC $x, $val:HW_WIRE
}
with [{
  if ((*$val.begin())->as<WireRef>().getNumUses() != 1)
    goto $fail;
}]
replace {
  HW_LOAD $x, $reg, $offs
}



// CONCAT -> sext/zext
match {
  HW_CONCAT $out, #'0, $x
}
replace {
  OP_ZEXT $out, $x
}

macro chk_wire $self, $len [{
  if (!(*$self.begin())->is<WireRef>())
    goto $fail;
  if (!$len.valueEquals(*(*$self.begin())->as<WireRef>().getNumBits()))
    goto $fail;
}]

macro chk_wire_constant $self, $len [{
  if (!(*$self.begin())->is<WireRef>())
    goto $fail;
  if (!(*$len.begin())->as<ConstantRef>().valueEquals(*(*$self.begin())->as<WireRef>().getNumBits()))
    goto $fail;
}]

macro chk_wire_like $self, $like [{
  if (!(*$self.begin())->is<WireRef>())
    goto $fail;
  if (*(*$self.begin())->as<WireRef>().getNumBits() == *(*$like.begin())->as<WireRef>().getNumBits())
    goto $fail;
}]

match {
  HW_SPLICE $sign, $x, $splice_offs:chk_const_len_of_minus1($x)
  HW_REPEAT $temp, $sign:chk_wire(#32'd1)
  HW_CONCAT $out, $temp:HW_WIRE, $x
}
replace {
  OP_SEXT $out, $x
}


// ICMP Opt
match {
  OP_ICMP_EQ $out, $in, #1'b0
}
replace {
  OP_NOT $out, $in
}

match {
  OP_ICMP_EQ $out, $in, #1'b1
}
replace $out -> $in

match {
  OP_ICMP_NE $out, $in, #1'b1
}
replace {
  OP_NOT $out, $in
}

match {
  OP_ICMP_NE $out, $in, #1'b0
}
replace $out -> $in

// move constants to RHS
match {
  $opc{OP_ICMP_EQ, OP_ICMP_NE} $out, $lhs:CORE_CONSTANT, $rhs:HW_WIRE
}
replace {
  $opc $out, $rhs, $lhs
}

// NOT Opt
match {
  OP_NOT $inv, $x
  OP_NOT $id, $inv:HW_WIRE
}
replace $id -> $x

match {
  OP_SUB $inv, #'0, $x
  OP_SUB $id, #'0, $inv:HW_WIRE
}
replace $id -> $x


// reverse negated cond IF
// impossible without reverse (can't match last)
// match {
//   OP_IF defs=2 $true_bl:CORE_BLOCK, $false_bl:CORE_BLOCK, $inputs..., $cond:HW_WIRE
// }


/*
// DeMorgan (n operand patterns...)
match {
  OP_NOT $x_neg, $x
  OP_NOT $y_neg, $y
  OP_AND $out_neg, $x, $y
}
replace {

}
*/

// Mux Opt
match {
  OP_NOT $cond, $cond_inv
  HW_MUX $out, $cond:HW_WIRE, $lhs, $rhs
}
replace {
  HW_MUX $out, $cond_inv, $rhs, $lhs
}

match {
  HW_MUX $out, $cond, $val, $val
}
replace $out -> $val

match {
  OP_NOT $sel_inv, $sel
  OP_AND $b, anyorder($val_b, $sel_inv:HW_WIRE)
  OP_AND $a, anyorder($val_a, $sel)
  OP_OR $out, $a:chk_wire(#32'b1), $b:HW_WIRE
}
replace {
  HW_MUX $out, $sel, $val_a, $val_b
}
// fixme: we need this twice (reverse order on the or) bc of matching limitations
match {
  OP_NOT $sel_inv, $sel
  OP_AND $b, anyorder($val_b, $sel_inv:HW_WIRE)
  OP_AND $a, anyorder($val_a, $sel)
  OP_OR $out, $b:chk_wire(#32'b1), $a:HW_WIRE
}
replace {
  HW_MUX $out, $sel, $val_a, $val_b
}

/*
// todo: multi-bit, reverse matching on the or
match {
  OP_AND $outA, anyorder($mask:HW_WIRE, $valA)
  OP_NOT $mask_inv, $mask
  OP_AND $outB, anyorder($mask_inv:HW_WIRE, $valB)
  OP_OR $out, /*fixme: should also support reverse/ $outB:HW_WIRE, $outA:HW_WIRE
}
with [{
  if (*(*$out.begin())->as<WireRef>().getNumBits() != 1)
    goto $fail;
}]
replace {
  HW_MUX $out, $mask, $valA, $valB
}
*/


match {
  HW_MUX $out, $cond, #1'b1, #1'b0
}
replace $out -> $cond

match {
  HW_MUX $out, $cond, #1'b0, #1'b1
}
replace {
  OP_NOT $out, $cond
}

/*
// these might hinder MUX tree analysis, maybe support output patterns in mux tree analysis?
match {
  HW_MUX $out, $cond, #'1, $rhs:HW_WIRE
}
replace {
  HW_REPEAT $temp:wire_like($out), $cond
  OP_OR $out, $temp, $rhs
}

match {
  HW_MUX $out, $cond, $rhs:HW_WIRE, #'1
}
replace {
  OP_NOT $conv_inv:wire_like($cond), $cond
  HW_REPEAT $temp:wire_like2($out), $conv_inv
  OP_OR $out, $temp, $rhs
}

match {
  HW_MUX $out, $cond, $lhs:HW_WIRE, #'0
}
replace {
  HW_REPEAT $temp:wire_like($out), $cond
  OP_AND $out, $temp, $lhs
}

match {
  HW_MUX $out, $cond, #'0, $lhs:HW_WIRE
}
replace {
  OP_NOT $conv_inv:wire_like($cond), $cond
  HW_REPEAT $temp:wire_like2($out), $conv_inv
  OP_AND $out, $temp, $lhs
}
*/

match {
  OP_TRUNC $out, $in:CORE_CONSTANT
}
with [{
  FatDynObjRef<> temp = cbuild.val((*$in.begin())->as<ConstantRef>()).resize(*(*$out.begin())->as<WireRef>().getNumBits()).get();
  $constTrunc = temp;
}]
replace $out -> $constTrunc


// fuse padding into insert instructions
// low side -> add to base offset
match {
  HW_SPLICE $short, $in, $offs:CORE_CONSTANT
  HW_INSERT $inserted, $short:HW_WIRE, $insval, $base, $terms...
  OP_TRUNC $low, $in
  HW_CONCAT $out, $pre..., $inserted:HW_WIRE, $low:chk_wire_constant($offs), $post...
}
with [{
  auto offsVal = (*$offs.begin())->as<ConstantRef>().getExactVal();
  auto shortSize = *(*$short.begin())->as<WireRef>().getNumBits();
  FatDynObjRef<> newWire = ctx.getWires().create(offsVal + shortSize);
  $temp = newWire;
  FatDynObjRef<> newWire2 = ctx.getWires().create(offsVal + shortSize);
  $temp2 = newWire2;
}]
replace {
  OP_TRUNC $temp, $in
  HW_INSERT $temp2, $temp, $insval, const_add($offs, $base), $terms...
  HW_CONCAT $out, $pre..., $temp2, $post...
}

// high side -> limited w/ max bounds
match {
  OP_TRUNC $short, $in
  HW_INSERT $inserted, $short:HW_WIRE, $insval, $base, $terms...
  HW_SPLICE $high, $in, $offs
  HW_CONCAT $out, /*$pre..., */$high:HW_WIRE, $inserted:chk_wire_constant($offs), $post...
}
with [{
  auto offsVal = (*$offs.begin())->as<ConstantRef>().getExactVal();
  auto highSize = *(*$high.begin())->as<WireRef>().getNumBits();
  FatDynObjRef<> newWire = ctx.getWires().create(offsVal + highSize);
  $temp = newWire;
  FatDynObjRef<> newWire2 = ctx.getWires().create(offsVal + highSize);
  $temp2 = newWire2;
}]
replace {
  OP_TRUNC $temp, $in
  HW_INSERT $temp2, $temp, $insval, $base, $terms...
  HW_CONCAT $out, /*$pre..., */$temp2, $post...
}


/*
macro wire32 -> $rv [{
  FatDynObjRef<> w = ctx.getWires().create(32);
  $rv = w;
}]

macro sort()

// shift + OR
match {
  OP_ZEXT $ext, $x
  OP_SLL $shifted, $ext, $shamt
  OP_OR $out, anyorder($shifted:HW_WIRE, $others...)
}
replace {
  OP_TRUNC $truncShamt:wire32(), $shamt
  OP_OR $temp:wire_like($out), $others...
  HW_SPLICE $origVal:wire_like($x), $temp, $truncShamt
  OP_OR $modVal:wire_like($x), $origVal, $x
  HW_INSERT $out, $temp, $modVal, $truncShamt

}
*/

/*
match {
  OP_ADD $sum, $a, $b
  OP_SUB $diff, $a, $b
  HW_MUX $out, $sel, $diff:HW_WIRE, $sum:HW_WIRE
}
replace {
  OP_SEXT $mask:wire_like($out), $sel
  OP_XOR $ones:wire_like($out), $b, $mask
  OP_ZEXT $zextVal:wire_like($out), $sel
  OP_ADD $out, $a, $ones, $zextVal
}
*/
