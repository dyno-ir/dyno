

macro const_negate $n -> $rv [{
  FatDynObjRef<> negated = cbuild.val((*$n.begin())->as<ConstantRef>()).neg().get();
  $rv = negated;
}]
macro constant_like $val, $other -> $rv [{
  FatDynObjRef<> constant = cbuild.val($val).resize(*(*$other.begin())->as<WireRef>().getNumBits(), false).get();
  $rv = constant;
}]
macro constant_like_anyorder_obj $val, $other -> $rv [{
  FatDynObjRef<> constant = cbuild.val($val).resize(*(*$other.begin()).as<WireRef>().getNumBits(), false).get();
  $rv = constant;
}]
macro wire_like $other -> $rv [{
  FatDynObjRef<> w = ctx.getWires().create((*$other.begin())->as<WireRef>().getNumBits()); $rv = w;
}]
macro wire_like2 $other -> $rv [{
  FatDynObjRef<> w2 = ctx.getWires().create((*$other.begin())->as<WireRef>().getNumBits()); $rv = w2;
}]
macro const_like_reg_len $op, $reg [{
  auto asConstant = (*$op.begin())->dyn_as<ConstantRef>();
  if (!asConstant) goto $fail;
  if (!asConstant.valueEquals(*(*$reg.begin())->as<RegisterRef>().getNumBits()))
    goto $fail;
}]
macro const_like_value_len $op, $wire [{
  auto asConstant = (*$op.begin())->dyn_as<ConstantRef>();
  if (!asConstant) goto $fail;
  if (!asConstant.valueEquals(*(*$wire.begin())->as<HWValue>().getNumBits()))
    goto $fail;
}]
macro const_len_of $obj -> $rv [{
  FatDynObjRef<> c = ConstantRef::fromU32(*(*$obj.begin())->as<HWValue>().getNumBits());
  $rv = c;
}]

macro const_len_of_minus1 $obj -> $rv [{
  FatDynObjRef<> c = ConstantRef::fromU32(*(*$obj.begin())->as<HWValue>().getNumBits() - 1);
  $rv = c;
}]

match {
  HW_MUX $out, #1'b1, $a, $b
}
replace $out -> $a

match {
  HW_MUX $out, #1'b0, $a, $b
}
replace $out -> $b


// # ADD/SUB rules
// sub to add negated
match {
  OP_SUB $subRes, $lhs, $rhs
  OP_ADD $res, anyorder($subRes:HW_WIRE, $others...)
}
replace {
  OP_NOT $temp2:wire_like($subRes), $rhs
  OP_ADD $res, $others..., $lhs, $temp2, constant_like(#1'b1, $res)
}

// sub to add negated
match {
  OP_ADD $temp, $others...
  OP_SUB $res, $temp:HW_WIRE, $rhs
}
replace {
  OP_NOT $temp2:wire_like($temp), $rhs
  OP_ADD $res, $others..., $temp2, constant_like(#1'b1, $res)
}

// sub constant -> add constant
match {
  OP_SUB $out, $lhs, $rhs:CORE_CONSTANT
}
replace {
  OP_ADD $out, $lhs, const_negate($rhs)
}

// todo: more than two operands in first add
match {
  OP_ADD $temp, $negatedA, $negatedB
  OP_NOT $temp2, $temp:HW_WIRE
  OP_ADD $out, anyorder($temp2:HW_WIRE, $others...)
}
replace {
  OP_NOT $a:wire_like($negatedA), $negatedA
  OP_NOT $b:wire_like2($negatedB), $negatedB
  OP_ADD $out, $a, $b, $others..., constant_like(#1'b1, $negatedA)
}

// Sink add thru MUX
// todo: reverse matching for certain regions to allow matching MUX the other way around
match {
  OP_ADD $sum0, anyorder($x, $gated)
  HW_MUX $mux_val, $disable, $x:HW_WIRE, $sum0:HW_WIRE
  OP_ADD $out, anyorder($mux_val:HW_WIRE, $others...)
}
replace {
  HW_MUX $gated_mux:wire_like($x), $disable, constant_like(#1'b0, $sum0), $gated
  OP_ADD $out, $x, $gated_mux, $others...
}



// patterns like this would be dope
// match {
//   OP_AND $first_sum, $first_args...
//   OP_ZEXT $first_sum_ext, $first_sum:HW_WIRE
//   OP_AND $sum, anyorder($first_sum_ext:HW_WIRE, $second_args...)
// }
// replace {
//   (OP_ZEXT $ext_first_args:wire_like($first_args), $first_args)...
//   OP_AND $sum, $ext_first_args..., $second_args...
// }



// # LOAD/STORE opt
// load with superfluous indexing
match {
  HW_LOAD $out, $reg, #'0, $len:const_like_reg_len($reg)
}
replace {
  HW_LOAD $out, $reg
}

// store with superfluous indexing
match {
  $opc{HW_STORE, HW_STORE_DEFER} $val, $reg, #'0, $len:const_like_reg_len($reg)
}
replace {
  $opc defs=0 $val, $reg
}

match {
  HW_STORE_DEFER $val, $reg, #'0, $len:const_like_reg_len($reg), $trig
}
replace {
  HW_STORE_DEFER defs=0 $val, $reg, $trig
}



// CONCAT OPT
// concat with zero length constant
match {
  HW_CONCAT $out, $pre..., #0', $post...
}
replace {
  HW_CONCAT $out, $pre..., $post...
}

match {
  HW_CONCAT $out, $x
}
replace $out -> $x



// Splice Opt
match {
  HW_SPLICE $out, $in, #32'b0, $len:const_like_value_len($in)
}
replace $out -> $in

match {
  HW_SPLICE $out, $in, #32'b0, $other_len
}
replace {
  OP_TRUNC $out, $in
}
// todo: C++ patterns for defragmenting splices

match {
  OP_TRUNC $trunc, $in
  HW_SPLICE $out, $in,            $old_addr:CORE_CONSTANT,   $old_len:CORE_CONSTANT,
                  $trunc:HW_WIRE, $trunc_addr:CORE_CONSTANT, $trunc_len:CORE_CONSTANT
}
with [{
  if (!(*$old_addr.begin())->as<ConstantRef>().valueEquals(*(*$trunc.begin())->as<WireRef>().getNumBits()))
    goto $fail;
  if (!(*$trunc_addr.begin())->as<ConstantRef>().valueEquals(0))
    goto $fail;
  if ((*$out.begin())->as<WireRef>().getNumBits() != (*$in.begin())->as<WireRef>().getNumBits())
    goto $fail;
}]
replace $out -> $in


// we need check duplicates of these. dyno dsl pattern matching should fix.
macro chk_const_diff_lens $self, $lhs, $rhs [{
  auto lhsBits = *(*$lhs.begin())->as<HWValue>().getNumBits();
  auto rhsBits = *(*$rhs.begin())->as<HWValue>().getNumBits();
  FatDynObjRef<> diff = ConstantRef::fromU32(lhsBits - rhsBits);
  if ((*$self.begin())->as<FatDynObjRef<>>() != diff)
    goto $fail;
}]
macro chk_const_len_of_minus1 $self, $obj [{
  FatDynObjRef<> c = ConstantRef::fromU32(*(*$obj.begin())->as<HWValue>().getNumBits() - 1);
  if ((*$self.begin())->as<FatDynObjRef<>>() != c)
    goto $fail;
}]



// trunc(ext()) patterns
match {
  $opc{OP_ZEXT, OP_SEXT, OP_ANYEXT} $ext, $x
  OP_TRUNC $out, $ext:HW_WIRE
}
with [{
  auto inBits = (*$x.begin())->as<HWValue>().getNumBits();
  auto outBits = (*$out.begin())->as<WireRef>().getNumBits();
  if (!(*outBits < *inBits))
    goto $fail;
}]
replace {
  OP_TRUNC $out, $x
}

match {
  $opc{OP_ZEXT, OP_SEXT, OP_ANYEXT} $ext, $x
  OP_TRUNC $out, $ext:HW_WIRE
}
with [{
  auto inBits = (*$x.begin())->as<HWValue>().getNumBits();
  auto outBits = (*$out.begin())->as<WireRef>().getNumBits();
  if (!(*outBits == *inBits))
    goto $fail;
}]
replace $out -> $x

match {
  $opc{OP_ZEXT, OP_SEXT, OP_ANYEXT} $ext, $x
  OP_TRUNC $out, $ext:HW_WIRE
}
with [{
  auto inBits = (*$x.begin())->as<HWValue>().getNumBits();
  auto outBits = (*$out.begin())->as<WireRef>().getNumBits();
  if (!(*outBits > *inBits))
    goto $fail;
}]
replace {
  $opc $out, $x
}



// trunc(load())
match {
  HW_LOAD $val, $reg
  OP_TRUNC $x, $val:HW_WIRE
}
with [{
  if ((*$val.begin())->as<WireRef>().getNumUses() != 1)
    goto $fail;
}]
replace {
  HW_LOAD $x, $reg, #32'h0, const_len_of($x)
}

match {
  HW_LOAD $val, $reg, $offs, $len
  OP_TRUNC $x, $val:HW_WIRE
}
with [{
  if ((*$val.begin())->as<WireRef>().getNumUses() != 1)
    goto $fail;
}]
replace {
  HW_LOAD $x, $reg, $offs, const_len_of($x)
}



// CONCAT -> sext/zext
match {
  HW_CONCAT $out, #'0, $x
}
replace {
  OP_ZEXT $out, $x
}

match {
  HW_SPLICE $sign, $x, $splice_offs:chk_const_len_of_minus1($x), #32'd1
  HW_REPEAT $temp, $sign:HW_WIRE, $repeat_cnt:chk_const_diff_lens($out, $x)
  HW_CONCAT $out, $temp:HW_WIRE, $x
}
replace {
  OP_SEXT $out, $x
}



// ICMP Opt
match {
  OP_ICMP_EQ $out, $in, #1'b0
}
replace {
  OP_NOT $out, $in
}

match {
  OP_ICMP_EQ $out, $in, #1'b1
}
replace $out -> $in

match {
  OP_ICMP_NE $out, $in, #1'b1
}
replace {
  OP_NOT $out, $in
}

match {
  OP_ICMP_NE $out, $in, #1'b0
}
replace $out -> $in



// NOT Opt
match {
  OP_NOT $inv, $x
  OP_NOT $id, $inv:HW_WIRE
}
replace $id -> $x

match {
  OP_SUB $inv, #'0, $x
  OP_SUB $id, #'0, $inv:HW_WIRE
}
replace $id -> $x


// reverse negated cond IF
// impossible without reverse (can't match last)
// match {
//   OP_IF defs=2 $true_bl:CORE_BLOCK, $false_bl:CORE_BLOCK, $inputs..., $cond:HW_WIRE
// }


/*
// DeMorgan (n operand patterns...)
match {
  OP_NOT $x_neg, $x
  OP_NOT $y_neg, $y
  OP_AND $out_neg, $x, $y
}
replace {

}
*/

// Mux Opt
match {
  OP_NOT $cond, $cond_inv
  HW_MUX $out, $cond:HW_WIRE, $lhs, $rhs
}
replace {
  HW_MUX $out, $cond_inv, $rhs, $lhs
}

/*
// these might hinder MUX tree analysis. skip for now, maybe support in mux tree analysis at some
match {
  HW_MUX $out, $cond, #'1, $rhs
}
replace {
  OP_SEXT $temp:wire_like($out), $cond
  OP_OR $out, $temp, $rhs
}

match {
  HW_MUX $out, $cond, $rhs, #'0
}
replace {
  OP_SEXT $temp:wire_like($out), $cond
  OP_AND $out, $temp, $rhs
}
*/


match {
  OP_TRUNC $out, $in:CORE_CONSTANT
}
with [{
  FatDynObjRef<> temp = cbuild.val((*$in.begin())->as<ConstantRef>()).resize(*(*$out.begin())->as<WireRef>().getNumBits()).get();
  $constTrunc = temp;
}]
replace $out -> $constTrunc

/*
macro wire32 -> $rv [{
  FatDynObjRef<> w = ctx.getWires().create(32);
  $rv = w;
}]

macro sort()

// shift + OR
match {
  OP_ZEXT $ext, $x
  OP_SLL $shifted, $ext, $shamt
  OP_OR $out, anyorder($shifted:HW_WIRE, $others...)
}
replace {
  OP_TRUNC $truncShamt:wire32(), $shamt
  OP_OR $temp:wire_like($out), $others...
  HW_SPLICE $origVal:wire_like($x), $temp, $truncShamt, $len:const_len_of($x)
  OP_OR $modVal:wire_like($x), $origVal, $x
  HW_INSERT $out, $temp, $modVal, $truncShamt, $len

}
*/

/*
match {
  OP_ADD $sum, $a, $b
  OP_SUB $diff, $a, $b
  HW_MUX $out, $sel, $diff:HW_WIRE, $sum:HW_WIRE
}
replace {
  OP_SEXT $mask:wire_like($out), $sel
  OP_XOR $ones:wire_like($out), $b, $mask
  OP_ZEXT $zextVal:wire_like($out), $sel
  OP_ADD $out, $a, $ones, $zextVal
}
*/
